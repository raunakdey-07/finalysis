{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { EventTypes } from \"../interfaces\";\nvar RotationGestureDetector = function () {\n  function RotationGestureDetector(callbacks) {\n    _classCallCheck(this, RotationGestureDetector);\n    _defineProperty(this, \"onRotationBegin\", void 0);\n    _defineProperty(this, \"onRotation\", void 0);\n    _defineProperty(this, \"onRotationEnd\", void 0);\n    _defineProperty(this, \"currentTime\", 0);\n    _defineProperty(this, \"previousTime\", 0);\n    _defineProperty(this, \"previousAngle\", 0);\n    _defineProperty(this, \"_rotation\", 0);\n    _defineProperty(this, \"_anchorX\", 0);\n    _defineProperty(this, \"_anchorY\", 0);\n    _defineProperty(this, \"isInProgress\", false);\n    _defineProperty(this, \"keyPointers\", [NaN, NaN]);\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n  return _createClass(RotationGestureDetector, [{\n    key: \"updateCurrent\",\n    value: function updateCurrent(event, tracker) {\n      this.previousTime = this.currentTime;\n      this.currentTime = event.time;\n      var _this$keyPointers = _slicedToArray(this.keyPointers, 2),\n        firstPointerID = _this$keyPointers[0],\n        secondPointerID = _this$keyPointers[1];\n      var firstPointerCoords = tracker.getLastAbsoluteCoords(firstPointerID);\n      var secondPointerCoords = tracker.getLastAbsoluteCoords(secondPointerID);\n      var vectorX = secondPointerCoords.x - firstPointerCoords.x;\n      var vectorY = secondPointerCoords.y - firstPointerCoords.y;\n      this._anchorX = (firstPointerCoords.x + secondPointerCoords.x) / 2;\n      this._anchorY = (firstPointerCoords.y + secondPointerCoords.y) / 2;\n      var angle = -Math.atan2(vectorY, vectorX);\n      this._rotation = Number.isNaN(this.previousAngle) ? 0 : this.previousAngle - angle;\n      this.previousAngle = angle;\n      if (this.rotation > Math.PI) {\n        this._rotation -= Math.PI;\n      } else if (this.rotation < -Math.PI) {\n        this._rotation += Math.PI;\n      }\n      if (this.rotation > Math.PI / 2) {\n        this._rotation -= Math.PI;\n      } else if (this.rotation < -Math.PI / 2) {\n        this._rotation += Math.PI;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      if (!this.isInProgress) {\n        return;\n      }\n      this.isInProgress = false;\n      this.keyPointers = [NaN, NaN];\n      this.onRotationEnd(this);\n    }\n  }, {\n    key: \"setKeyPointers\",\n    value: function setKeyPointers(tracker) {\n      if (this.keyPointers[0] && this.keyPointers[1]) {\n        return;\n      }\n      var pointerIDs = tracker.trackedPointers.keys();\n      this.keyPointers[0] = pointerIDs.next().value;\n      this.keyPointers[1] = pointerIDs.next().value;\n    }\n  }, {\n    key: \"onTouchEvent\",\n    value: function onTouchEvent(event, tracker) {\n      switch (event.eventType) {\n        case EventTypes.DOWN:\n          this.isInProgress = false;\n          break;\n        case EventTypes.ADDITIONAL_POINTER_DOWN:\n          if (this.isInProgress) {\n            break;\n          }\n          this.isInProgress = true;\n          this.previousTime = event.time;\n          this.previousAngle = NaN;\n          this.setKeyPointers(tracker);\n          this.updateCurrent(event, tracker);\n          this.onRotationBegin(this);\n          break;\n        case EventTypes.MOVE:\n          if (!this.isInProgress) {\n            break;\n          }\n          this.updateCurrent(event, tracker);\n          this.onRotation(this);\n          break;\n        case EventTypes.ADDITIONAL_POINTER_UP:\n          if (!this.isInProgress) {\n            break;\n          }\n          if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n            this.finish();\n          }\n          break;\n        case EventTypes.UP:\n          if (this.isInProgress) {\n            this.finish();\n          }\n          break;\n      }\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.keyPointers = [NaN, NaN];\n      this.isInProgress = false;\n    }\n  }, {\n    key: \"anchorX\",\n    get: function get() {\n      return this._anchorX;\n    }\n  }, {\n    key: \"anchorY\",\n    get: function get() {\n      return this._anchorY;\n    }\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this._rotation;\n    }\n  }, {\n    key: \"timeDelta\",\n    get: function get() {\n      return this.currentTime + this.previousTime;\n    }\n  }]);\n}();\nexport { RotationGestureDetector as default };","map":{"version":3,"names":["EventTypes","RotationGestureDetector","callbacks","_classCallCheck","_defineProperty","NaN","onRotationBegin","onRotation","onRotationEnd","_createClass","key","value","updateCurrent","event","tracker","previousTime","currentTime","time","_this$keyPointers","_slicedToArray","keyPointers","firstPointerID","secondPointerID","firstPointerCoords","getLastAbsoluteCoords","secondPointerCoords","vectorX","x","vectorY","y","_anchorX","_anchorY","angle","Math","atan2","_rotation","Number","isNaN","previousAngle","rotation","PI","finish","isInProgress","setKeyPointers","pointerIDs","trackedPointers","keys","next","onTouchEvent","eventType","DOWN","ADDITIONAL_POINTER_DOWN","MOVE","ADDITIONAL_POINTER_UP","indexOf","pointerId","UP","reset","get","default"],"sources":["C:\\Users\\rauna\\Project Finalysis\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\detectors\\RotationGestureDetector.ts"],"sourcesContent":["import { AdaptedEvent, EventTypes } from '../interfaces';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n}\n\nexport default class RotationGestureDetector\n  implements RotationGestureListener\n{\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n\n  private currentTime = 0;\n  private previousTime = 0;\n\n  private previousAngle = 0;\n  private _rotation = 0;\n\n  private _anchorX = 0;\n  private _anchorY = 0;\n\n  private isInProgress = false;\n\n  private keyPointers: number[] = [NaN, NaN];\n\n  constructor(callbacks: RotationGestureListener) {\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  private updateCurrent(event: AdaptedEvent, tracker: PointerTracker): void {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n\n    const firstPointerCoords = tracker.getLastAbsoluteCoords(firstPointerID);\n    const secondPointerCoords = tracker.getLastAbsoluteCoords(secondPointerID);\n\n    const vectorX: number = secondPointerCoords.x - firstPointerCoords.x;\n    const vectorY: number = secondPointerCoords.y - firstPointerCoords.y;\n\n    this._anchorX = (firstPointerCoords.x + secondPointerCoords.x) / 2;\n    this._anchorY = (firstPointerCoords.y + secondPointerCoords.y) / 2;\n\n    // Angle diff should be positive when rotating in clockwise direction\n    const angle: number = -Math.atan2(vectorY, vectorX);\n\n    this._rotation = Number.isNaN(this.previousAngle)\n      ? 0\n      : this.previousAngle - angle;\n\n    this.previousAngle = angle;\n\n    if (this.rotation > Math.PI) {\n      this._rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this._rotation += Math.PI;\n    }\n\n    if (this.rotation > Math.PI / 2) {\n      this._rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this._rotation += Math.PI;\n    }\n  }\n\n  private finish(): void {\n    if (!this.isInProgress) {\n      return;\n    }\n\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this);\n  }\n\n  private setKeyPointers(tracker: PointerTracker): void {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n\n    const pointerIDs: IterableIterator<number> = tracker.trackedPointers.keys();\n\n    this.keyPointers[0] = pointerIDs.next().value as number;\n    this.keyPointers[1] = pointerIDs.next().value as number;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n        this.isInProgress = true;\n\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n\n        this.setKeyPointers(tracker);\n\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        this.updateCurrent(event, tracker);\n        this.onRotation(this);\n\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish();\n        }\n\n        break;\n\n      case EventTypes.UP:\n        if (this.isInProgress) {\n          this.finish();\n        }\n        break;\n    }\n\n    return true;\n  }\n\n  public reset(): void {\n    this.keyPointers = [NaN, NaN];\n    this.isInProgress = false;\n  }\n\n  public get anchorX() {\n    return this._anchorX;\n  }\n\n  public get anchorY() {\n    return this._anchorY;\n  }\n\n  public get rotation() {\n    return this._rotation;\n  }\n\n  public get timeDelta() {\n    return this.currentTime + this.previousTime;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}